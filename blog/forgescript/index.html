<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Foundry forge script 一二事。some details that need attention | Random thoughts here</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto flex place-content-between py-16 lg:py-8 font-sans text-6xl lg:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/x-mathjax-config>
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$']]}
      });
    </script><div class="container mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl lg:text-base">2024-07-18</div><h1 class="w-full mt-4 mb-8 font-serif text-8xl lg:text-4xl text-slate-900 dark:text-slate-300">Foundry forge script 一二事。some details that need attention</h1><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class=prose-boring><p>​ 不久前 All solve了 <a href=https://onlypwner.xyz>ONLYPWNER</a> 靶场，Rank 10。期间遇到了不少因为<code>forge</code>特性而导致的问题，记录一下以备查阅。<h3 id=simulation-failed>Simulation Failed</h3><p>​ Forge Script在执行时一共有两层仿真，第一层允许使用cheatcode，字节码的运行时实现依赖的是foundry代理过的；而第二层就基本与真实的EVM环境一致。<p>​ 第二层仿真时不会为cheatcode而报错，只是会不起作用，从而导致一些受影响于cheatcode修改的环境的代码错误。<p>​ 比如我在Script脚本中写了<code>vm.wrap(xxx)</code>，但是在simulation时不会生效，也就导致了这一错误。<p>​ 这一问题可以通过<code>--skip-simulation</code>来解决，不过解决这个没啥意义，broadcast上链之后也不允许你用这些修改环境的cheatcode。需要指定某一个blocknumber，或者需要使得timestamp在某一个区间内，建议的做法是把要执行的脚本找一个合约包装起来，然后再写一个Script或者用cast来触发。<h3 id=0-bytes-of-code>0 bytes of code</h3><p>​ 这是forge script的经典问题，无法处理0 bytes的contract。比方说我用CREATE/CREATE2去执行了一段initialize code，但是不返回任何runtime code，forge script 大概率就会报这个错。以及调用<code>Selfdestruct</code>（CTF中比较常见）时会造成合约的代码为0，forge script在这种时候就不会起作用。<p>​ 我个人比较喜欢用 CREATE/CREATE2 来实现一些任务，以及其他一些情况不得不需要这么处理的话也得避免这一任务在simulation中出现，类似上一个问题的解法。<p>​ 网上很多建议会说试试<code>--skip-simulation</code>，这是无效的，因为这只会跳过第二次的仿真，而 Script 会在第一次报错。<del>尚且不知道第二次仿真能否处理因为无法到达这一步</del><h3 id=vm-startbroadcast>vm.startBroadcast</h3><p>​ 刚开始用foundry forge的时候对<code>vm.startBroadcast()</code>印象最深，以为是用intialize 封装了整个broadcast的脚本内容，<em>然而实际上并没有</em>。Script 的每一次external call都是隔离的交易，由于网络因素交易之间可能时间差距会很大，也没有办法保证后面的就正确执行/不会被抢先。<p>​ <code>vm.startBroadcast()</code>会把交易的发出者更改为命令行传入的<code>--private-key</code>参数对应的地址。也可以通过加参数来改为其他。所以如果想要重入的话一般不要把重入函数写在Script的fallback/recevive里，还是得另外再开一个辅助合约。<p>​ 还有一点难以意识到的是即使你指定了<code>--broadcast</code>，也只会广播<code>vm.startBroadcast</code>和<code>vm.stopBroadcast</code>包裹的内容。同理你要是不指定<code>is Script</code>或<code>vm.startBroadcast</code>，大概率也不会广播。<h3 id=unknown-contract-at-address-0xbebe>Unknown contract at address 0xbebe…</h3><p>​ 这是指定<code>--debug</code>调试时可能会出现的问题，forge 不会把你的源代码映射到这一地址上。好像有 feature request 有提到这一点，不知道现在实现了没有。<del>如果有的话可以告诉我一声</del><p>​ 调试方案我目前一般还是使用 electron.js 构建的 remix desktop（remix online连anvil啥的容易触发CORS），较短的、没啥环境依赖的代码可以丢到<a href=https://www.evm.codes/playground>EVM.code playground</a> 。forge这个终端调试实在不方便看栈上数据、内存数据等。<h3 id=others>Others</h3><p>​ Foundry 最好用的应该还是用来test和fuzz啥的，以及很多的 cheatcode 和 console。<a href=https://book.getfoundry.sh/>文档</a><p>​ 其他的目前想不起来。以后遇到了或者想起来了在写吧。有问题欢迎找我…</div></div></section>