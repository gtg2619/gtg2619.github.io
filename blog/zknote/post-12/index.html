<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Encrypted Polynomial Evalution | Random thoughts here</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto flex place-content-between py-16 lg:py-8 font-sans text-6xl lg:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/zknote/> /zknote </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/x-mathjax-config>
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$']]}
      });
    </script><div class="container mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl lg:text-base">2024-03-10</div><h1 class="w-full mt-4 mb-8 font-serif text-8xl lg:text-4xl text-slate-900 dark:text-slate-300">Encrypted Polynomial Evalution</h1><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class=prose-boring><h3 id=encrypted-polynomial-evaluation>Encrypted Polynomial Evaluation</h3><h3 id=encrypted-exponentiation>Encrypted Exponentiation</h3><p>Known pairing mappings satisfy the requirement for single-multiplication homomorphisms (Further pairings lead to huge dimensions, which is unacceptable for concise zkp), but we still need to do homomorphic encryption for exponents.<p>For that purpose, we could let prover computes the encrypted value of $x$, $x^2$, and $x_3$ and gives those the verifier separately. The supplied cryptographic parameters are still valid for the verifier because the supplied cryptographic parameters are within a computable (given) elliptic curve group.<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>from </span><span>py_ecc</span><span style=color:#81a1c1>.</span><span>bn128 </span><span style=color:#81a1c1>import </span><span>G1</span><span style=color:#eceff4>, </span><span>multiply</span><span style=color:#eceff4>, </span><span>add</span><span style=color:#eceff4>, </span><span>neg</span><span style=color:#eceff4>, </span><span>eq
</span><span>
</span><span style=color:#616e88># Prover
</span><span>x </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>5
</span><span>
</span><span>X3 </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>5</span><span style=color:#81a1c1>**</span><span style=color:#b48ead>3</span><span>)
</span><span>X2 </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>5</span><span style=color:#81a1c1>**</span><span style=color:#b48ead>2</span><span>)
</span><span>X </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>5</span><span>)
</span><span>
</span><span style=color:#616e88># Verifier
</span><span>left_hand_side </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>39</span><span>)
</span><span>right_hand_side </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(X3</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>)</span><span style=color:#eceff4>,
</span><span>                              </span><span style=color:#88c0d0>multiply</span><span>(</span><span style=color:#88c0d0>neg</span><span>(X2)</span><span style=color:#eceff4>, </span><span style=color:#b48ead>4</span><span>))</span><span style=color:#eceff4>,
</span><span>                              </span><span style=color:#88c0d0>multiply</span><span>(X</span><span style=color:#eceff4>, </span><span style=color:#b48ead>3</span><span>))</span><span style=color:#eceff4>,
</span><span>                              </span><span style=color:#88c0d0>multiply</span><span>(</span><span style=color:#88c0d0>neg</span><span>(G1)</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>))
</span><span>
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>eq</span><span>(left_hand_side</span><span style=color:#eceff4>, </span><span>right_hand_side), </span><span style=color:#a3be8c>"lhs ≠ rhs"
</span></code></pre><h3 id=trusted-setup>Trusted Setup</h3><p>Counterintuitively, we typically use the above construction in reverse.<p>For evaluation of the polynomial<p>$$ result = \sum_{i=0}^{d}c_i x^i $$<p>we have a trusted third party generate a secret $\tau$ value and encrypt it as<p>$$ \tau[G],\ \tau^2[G],\ \tau^3[G]\ …\ \tau^d[G] $$<p>And the prover will plug this into their polynomial with coefficients $c_i$<p>$$ [result] = c_0[G]+c_1[\tau G]+c_2[\tau^2 G]+…+c_d[\tau^d G] $$<p>The <code>[result]</code> is the same value as if we had evaluated the polynomial directly:<p>$$ [result] = c_0[G]+c_1\tau [G]+c_2\tau^2 [G]+…+c_d\tau^d [G] $$<p>The important point here is that we can evaluate polynomials using elliptic curve points and get a valid output, but without knowing the point we evaluated the polynomial at.<h3 id=polynomials-over-finite-fields>polynomials over finite fields</h3><pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>from </span><span>py_ecc</span><span style=color:#81a1c1>.</span><span>bn128 </span><span style=color:#81a1c1>import </span><span>G1</span><span style=color:#eceff4>, </span><span>multiply</span><span style=color:#eceff4>, </span><span>add</span><span style=color:#eceff4>, </span><span>curve_order</span><span style=color:#eceff4>, </span><span>eq</span><span style=color:#eceff4>, </span><span>Z1
</span><span style=color:#81a1c1>from </span><span>functools </span><span style=color:#81a1c1>import </span><span style=color:#88c0d0;font-style:italic>reduce
</span><span style=color:#81a1c1>import </span><span>galois
</span><span>
</span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#a3be8c>"initializing a large field, this may take a while..."</span><span>)
</span><span style=color:#81a1c1>GF = </span><span>galois</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>GF</span><span>(curve_order)
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>inner_product</span><span>(ec_points</span><span style=color:#eceff4>, </span><span>coeffs):
</span><span>    </span><span style=color:#81a1c1>return </span><span style=color:#88c0d0;font-style:italic>reduce</span><span>(add</span><span style=color:#eceff4>, </span><span>(</span><span style=color:#88c0d0>multiply</span><span>(point</span><span style=color:#eceff4>, </span><span style=color:#81a1c1>int</span><span>(coeff)) </span><span style=color:#81a1c1>for </span><span>point</span><span style=color:#eceff4>, </span><span>coeff </span><span style=color:#81a1c1>in </span><span style=color:#88c0d0;font-style:italic>zip</span><span>(ec_points</span><span style=color:#eceff4>, </span><span>coeffs))</span><span style=color:#eceff4>, </span><span>Z1)
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>generate_powers_of_tau</span><span>(tau</span><span style=color:#eceff4>, </span><span>degree):
</span><span>    </span><span style=color:#81a1c1>return </span><span>[</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#81a1c1>int</span><span>(tau </span><span style=color:#81a1c1>** </span><span>i)) </span><span style=color:#81a1c1>for </span><span>i </span><span style=color:#81a1c1>in </span><span style=color:#88c0d0;font-style:italic>range</span><span>(degree </span><span style=color:#81a1c1>+ </span><span style=color:#b48ead>1</span><span>)]
</span><span>
</span><span style=color:#616e88># p = (x - 4) * (x + 2)
</span><span>p </span><span style=color:#81a1c1>= </span><span>galois</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>Poly</span><span>([</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span style=color:#81a1c1>-</span><span style=color:#b48ead>4</span><span>]</span><span style=color:#eceff4>, </span><span>field</span><span style=color:#81a1c1>=GF</span><span>) </span><span style=color:#81a1c1>* </span><span>galois</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>Poly</span><span>([</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>2</span><span>]</span><span style=color:#eceff4>, </span><span>field</span><span style=color:#81a1c1>=GF</span><span>)
</span><span>
</span><span style=color:#616e88># evaluate at 8
</span><span>tau </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>GF</span><span>(</span><span style=color:#b48ead>8</span><span>)
</span><span>
</span><span style=color:#616e88># evaluate then convert
</span><span>powers_of_tau </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>generate_powers_of_tau</span><span>(tau</span><span style=color:#eceff4>, </span><span>p</span><span style=color:#81a1c1>.</span><span>degree)
</span><span>evaluate_then_convert_to_ec </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#81a1c1>int</span><span>(</span><span style=color:#88c0d0>p</span><span>(tau)))
</span><span>
</span><span style=color:#616e88># evaluate via encrypted evaluation# coefficients need to be reversed to match the powers
</span><span>evaluate_on_ec </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>inner_product</span><span>(powers_of_tau</span><span style=color:#eceff4>, </span><span>p</span><span style=color:#81a1c1>.</span><span>coeffs[</span><span style=color:#eceff4>::</span><span style=color:#81a1c1>-</span><span style=color:#b48ead>1</span><span>])
</span><span>
</span><span style=color:#81a1c1>if </span><span style=color:#88c0d0>eq</span><span>(evaluate_then_convert_to_ec</span><span style=color:#eceff4>, </span><span>evaluate_on_ec):
</span><span>    </span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#a3be8c>"elliptic curve points are equal"</span><span>)
</span></code></pre><h3 id=schwartz-zippel-lemma-and-the-motivation-for-encrypted-polynomial-evaluation>Schwartz Zippel Lemma and the motivation for encrypted polynomial evaluation</h3><p><em>Pure copying. I think I need to understand it later</em><p>The Schwartz-Zippel Lemma says that two unequal polynomials almost never overlap except at a number of points constrained by the degree. In a big prime finite field (i.e. a prime number with a couple hundred bits), the degree is going to be vanishingly small compared to the order of the field. So if we evaluate two different polynomials at a random point x and they evaluate to the same value, then we can be almost perfectly certain the two polynomials are the same <em>even if we don’t know the polynomials</em>.<p>As it is, we have enough tooling for a prover to prove to the verifier that they have four polynomials 𝓐(x), 𝓑(x), 𝓒(x), and 𝓓(x) such that 𝓐𝓑 = 𝓒𝓓, and the verifier can certify this fact without learning the polynomials.<p>The prover will execute the encrypted evaluation of all four polynomials to obtain scalars A, B, C, and D and give that to the verifier. The verifier can then carry out AB = CD to see the prover’s claim is true. The prover doesn’t know what point they are evaluating at so they can’t architect polynomials that intersect at the point the third party setup chose (assuming no collusion).<p>Okay, we have AB = CD, but how is that useful?<p>This starts to get interesting when the verifier can require the prover to use a known polynomial for D. This is not enough for the verifier to learn A, B, or C, but it puts known constraints on what polynomials the prover can use for A, B, and C.<p>For example, one important feature is that the verifier now knows AB has the same roots (and possible others) as D because when polynomials are multiplied by a non-zero polynomial, the roots of the product polynomial is the union of the roots of the constituent polynomials. Therefore, the roots of polynomial 𝓓 must be a subset of the roots of 𝓐𝓑.<p>Another subtle way to constrain the verifier is to only supply them encrypted powers of x up to a limited power. This constrains the degree of the polynomial 𝓐𝓑.<p>A unknown polynomial with a known upper bound on the degree and a known set of roots is not unique, but nonetheless “says something” and can be used to encode information with some clever transformations. This should start to give you a foggy idea of how succinct zero knowledge proofs are possible.<p>Another teaser is that the setup ceremony “powers of tau” derives its name from creating a lot of powers of a hidden value so encrypted polynomials can be calculated from it, similar to what we described in this section.<p>The purpose of this article is only to introduce the concept of a trusted setup and encrypted polynomial evaluation, so we must stop here. But now that we know how to handle addition, multiplication, and exponentiation in an encrypted manner, we are ready to encode and encrypt arbitrary calculations, with the added bonus that we have a vague idea of how to make them succinct.</div></div></section>