<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Groth16 Explained | Random thoughts here</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto flex place-content-between py-16 lg:py-8 font-sans text-6xl lg:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/zknote/> /zknote </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/x-mathjax-config>
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$']]}
      });
    </script><div class="container mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl lg:text-base">2024-03-10</div><h1 class="w-full mt-4 mb-8 font-serif text-8xl lg:text-4xl text-slate-900 dark:text-slate-300">Groth16 Explained</h1><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class=prose-boring><h3 id=groth16-explained>Groth16 Explained</h3><p>The groth16 algorithm enables a quadratic arithmetic program to be computed by a prover over elliptic curve points derived in a trusted setup, and quickly checked by a verifier. It uses auxiliary elliptic curve points from the trusted setup to prevent forged proofs.<p>In our chapter on evaluating a Quadratic Arithmetic Program at a hidden point τ, we had a significant issue that the prover can simply invent values a, b, c where ab = c and present those as elliptic curve points to the verifier.<p>Thus, the verifier has no idea if elliptic curve points $[A]_1$, $[B]_2$, and $[C]_1$ were the result of a satisfied QAP or made up values.<h3 id=preventing-forgery-using-a-and-b>Preventing forgery using α and β</h3><p>update $[A]_1$ and $[B]_2$ $$ [A]_1 \leftarrow [A]_1 + [\alpha]_1 \ [B]_2 \leftarrow [B]_2 + [\beta]_2 \ $$ Naturally, the formula used for verification also needs to be modified.<p>For the original formula we have $$ \sum_{i=0}^{m}a_iu_i\left(x\right)\sum_{i=0}^{m}a_iv_i\left(x\right) = \sum_{i=0}^{m}a_iw_i\left(x\right)+h\left(x\right)t\left(x\right) $$<p>Substitute it into the modified formula to replace<p>$$ \left(\sum_{i=0}^{m}a_iu_i\left(x\right)+\alpha\right)\left(\sum_{i=0}^{m}a_iv_i\left(x\right)+\beta\right) = \alpha\beta+\beta\sum_{i=0}^{m}a_iu_i\left(x\right)+\alpha\sum_{i=0}^{m}a_iv_i\left(x\right)+\sum_{i=0}^{m}a_iu_i\left(x\right)\sum_{i=0}^{m}a_iv_i\left(x\right) $$<p>thus we have $$ \left(\sum_{i=0}^{m}a_iu_i\left(x\right)+\alpha\right)\left(\sum_{i=0}^{m}a_iv_i\left(x\right)+\beta\right) = \alpha\beta+\sum_{i=0}^ma_i\left(\beta u_i(x)+\alpha v_i(x)+w_i(x)\right)+h(x)t(x) $$ That is the verification process that verifier needs to do, $pairing([A]_1, [B]_2)= pairing([\alpha]_1,[\beta]_2)+pairing([C]_1,G_2)$<h3 id=separating-public-and-private-inputs-with-g-and-d>separating public and private inputs with γ and δ</h3><p>how we split the QAP into the portions computed by the verifier (the public inputs) and the prover (the private inputs): $$ \sum_{i=0}^{m}a_iw_i(x) = \sum_{i=0}^{\vartheta}a_iw_i(x) + \sum_{i=\vartheta+1}^{m}a_iw_i(x) $$<p>thus our proving formula would be optimized: $$ pairing([A]_1, [B]_2) = \ pairing([\alpha]_1,[\beta]_2)\<ul><li>pairing(\sum_{i=0}^{\vartheta}a_i\left(\beta u_i(x)+\alpha v_i(x)+w_i(x)\right),G_2) + \sum_{i=\vartheta+1}^ma_i\left[\beta u_i(x)+\alpha v_i(x)+w_i(x)\right]_1+[h(x)t(x)]_1 $$</ul><h3 id=preventing-forgeries-with-public-inputs>Preventing forgeries with public inputs</h3><p>To prevent this, the trusted setup agent divides w₀(τ) and w₁(τ) by a secret variable γ the prover portion by a different variable δ. The encrypted versions of these variables [γ] and [δ] are made available so that the verifier and prover can cancel them out if they are honest.<p>Verification step with γ and δ:<p>Instead of pairing with G₂ at the verification step, we pair with [γ] and [δ], The [γ] and [δ] terms will cancel out if the prover truly used the polynomials from the trusted setup. The prover (and verifier) do not know the field element that corresponds to [δ], so they cannot cause the terms to cancel out unless they use the values from the trusted setup.<h3 id=enforcing-true-zero-knowledge-r-and-s>Enforcing true zero knowledge: r and s</h3><p>If an attacker is able to guess our witness vector (which is possible if there is only a small range of valid inputs, e.g. secret voting from privileged addresses), then they can verify their guess is correct by comparing their constructed proof to the original proof.<p>To do this, we introduce another random shift, but this time at the proving phase instead of the setup phase.</div></div></section>