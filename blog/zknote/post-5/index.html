<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Elliptic Curve over Finite Field | Random thoughts here</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto flex place-content-between py-16 lg:py-8 font-sans text-6xl lg:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/zknote/> /zknote </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/x-mathjax-config>
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$']]}
      });
    </script><div class="container mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl lg:text-base">2024-03-10</div><h1 class="w-full mt-4 mb-8 font-serif text-8xl lg:text-4xl text-slate-900 dark:text-slate-300">Elliptic Curve over Finite Field</h1><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class=prose-boring><h3 id=bn128-formula>bn128 formula</h3><p>The bn128 curve, which is used by the <a href=https://www.rareskills.io/post/solidity-precompiles>Ethereum precompiles</a> to verify zk proofs, is specified as follows:<p>$$ y^2 = x^3 + 3\space\left(mod\space21888242871839275222246405745257275088696311157297823662689037894645226208583\right) $$<p>The field_modulus should not be confused with the curve order, which is the number of points on the curve.<p>use the <a href=https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm>Tonelli Shanks Algorithm</a> to compute modular square roots - you can treat it as a black box that computes the mathematical square root of a field element over a modulus, or lets you know if the square root does not exist.<p>use libnum to compute this<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>from </span><span>libnum </span><span style=color:#81a1c1>import </span><span>has_sqrtmod_prime_power</span><span style=color:#eceff4>, </span><span>has_sqrtmod_prime_power</span><span style=color:#eceff4>, </span><span>sqrtmod_prime_power
</span><span>
</span><span style=color:#616e88># the functions take arguments# has_sqrtmod_prime_power(n, field_mod, k), where n**k,
</span><span style=color:#616e88># but we aren't interested in powers in modular fields, so we set k = 1
</span><span style=color:#616e88># check if sqrt(8) mod 11 exists
</span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#88c0d0>has_sqrtmod_prime_power</span><span>(</span><span style=color:#b48ead>8</span><span style=color:#eceff4>, </span><span style=color:#b48ead>11</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>))
</span><span style=color:#616e88># False
</span><span>
</span><span style=color:#616e88># check if sqrt(5) mod 11 exists
</span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#88c0d0>has_sqrtmod_prime_power</span><span>(</span><span style=color:#b48ead>5</span><span style=color:#eceff4>, </span><span style=color:#b48ead>11</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>))
</span><span style=color:#616e88># True
</span><span>
</span><span style=color:#616e88># compute sqrt(5) mod 11
</span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#81a1c1>list</span><span>(</span><span style=color:#88c0d0>sqrtmod_prime_power</span><span>(</span><span style=color:#b48ead>5</span><span style=color:#eceff4>, </span><span style=color:#b48ead>11</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>)))
</span><span style=color:#616e88># [4, 7]
</span><span>
</span><span style=color:#81a1c1>assert </span><span>(</span><span style=color:#b48ead>4 </span><span style=color:#81a1c1>** </span><span style=color:#b48ead>2</span><span>) </span><span style=color:#81a1c1>% </span><span style=color:#b48ead>11 </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>5
</span><span style=color:#81a1c1>assert </span><span>(</span><span style=color:#b48ead>7 </span><span style=color:#81a1c1>** </span><span style=color:#b48ead>2</span><span>) </span><span style=color:#81a1c1>% </span><span style=color:#b48ead>11 </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>5
</span><span>
</span><span style=color:#616e88># we expect 4 and 7 to be inverses of each other, because in "regular" math, the two solutions to a square root are sqrt and -sqrt
</span><span style=color:#81a1c1>assert </span><span>(</span><span style=color:#b48ead>4 </span><span style=color:#81a1c1>+ </span><span style=color:#b48ead>7</span><span>) </span><span style=color:#81a1c1>% </span><span style=color:#b48ead>11 </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>0
</span></code></pre><h3 id=generating-elliptic-curve-cyclic-group-y2-x3-3-mod-11>Generating elliptic curve cyclic group y² = x³ + 3 (mod 11)</h3><pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>import </span><span>libnum
</span><span style=color:#81a1c1>import </span><span>matplotlib</span><span style=color:#81a1c1>.</span><span>pyplot </span><span style=color:#81a1c1>as </span><span>plt
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>generate_points</span><span>(mod):
</span><span>    xs </span><span style=color:#81a1c1>= </span><span>[]
</span><span>    ys </span><span style=color:#81a1c1>= </span><span>[]
</span><span>    </span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>y_squared</span><span>(x):
</span><span>        </span><span style=color:#81a1c1>return </span><span>(x</span><span style=color:#81a1c1>**</span><span style=color:#b48ead>3 </span><span style=color:#81a1c1>+ </span><span style=color:#b48ead>3</span><span>) </span><span style=color:#81a1c1>% </span><span>mod
</span><span>
</span><span>    </span><span style=color:#81a1c1>for </span><span>x </span><span style=color:#81a1c1>in </span><span style=color:#88c0d0;font-style:italic>range</span><span>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>, </span><span>mod):
</span><span>        </span><span style=color:#81a1c1>if </span><span>libnum</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>has_sqrtmod_prime_power</span><span>(</span><span style=color:#88c0d0>y_squared</span><span>(x)</span><span style=color:#eceff4>, </span><span>mod</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>):
</span><span>            square_roots </span><span style=color:#81a1c1>= </span><span>libnum</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>sqrtmod_prime_power</span><span>(</span><span style=color:#88c0d0>y_squared</span><span>(x)</span><span style=color:#eceff4>, </span><span>mod</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>)
</span><span>
</span><span>            </span><span style=color:#616e88># we might have two solutions
</span><span>            </span><span style=color:#81a1c1>for </span><span>sr </span><span style=color:#81a1c1>in </span><span>square_roots:
</span><span>                ys</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>append</span><span>(sr)
</span><span>                xs</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>append</span><span>(x)
</span><span>    </span><span style=color:#81a1c1>return </span><span>xs, ys
</span><span>
</span><span>
</span><span>xs, ys </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>generate_points</span><span>(</span><span style=color:#b48ead>11</span><span>)
</span><span>fig, (ax1) </span><span style=color:#81a1c1>= </span><span>plt</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>subplots</span><span>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>1</span><span>)</span><span style=color:#eceff4>;
</span><span>fig</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>suptitle</span><span>(</span><span style=color:#a3be8c>'y^2 = x^3 + 3 (mod p)'</span><span>)</span><span style=color:#eceff4>;
</span><span>fig</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>set_size_inches</span><span>(</span><span style=color:#b48ead>6</span><span style=color:#eceff4>, </span><span style=color:#b48ead>6</span><span>)</span><span style=color:#eceff4>;
</span><span>ax1</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>set_xticks</span><span>(</span><span style=color:#88c0d0;font-style:italic>range</span><span>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>,</span><span style=color:#b48ead>11</span><span>))</span><span style=color:#eceff4>;
</span><span>ax1</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>set_yticks</span><span>(</span><span style=color:#88c0d0;font-style:italic>range</span><span>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>,</span><span style=color:#b48ead>11</span><span>))</span><span style=color:#eceff4>;
</span><span>plt</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>grid</span><span>()
</span><span>plt</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>scatter</span><span>(xs</span><span style=color:#eceff4>, </span><span>ys)
</span><span>plt</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>show</span><span>()
</span></code></pre><ul><li>Just like the real-valued plot, the modular one “appears symmetric”</ul><p>The order is not the modulus<h3 id=python-bn128-library>Python bn128 library</h3><p>The library the EVM implementation <a href=https://github.com/ethereum/py-evm>pyEVM</a> uses for the elliptic curve precompiles is <a href=https://github.com/ethereum/py_ecc>py ecc</a>.<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>from </span><span>py_ecc</span><span style=color:#81a1c1>.</span><span>bn128 </span><span style=color:#81a1c1>import </span><span>G1</span><span style=color:#eceff4>, </span><span>multiply</span><span style=color:#eceff4>, </span><span>add</span><span style=color:#eceff4>, </span><span>eq</span><span style=color:#eceff4>, </span><span>neg
</span><span>
</span><span style=color:#88c0d0;font-style:italic>print</span><span>(G1)
</span><span style=color:#616e88># (1, 2)
</span><span>
</span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#88c0d0>add</span><span>(G1</span><span style=color:#eceff4>, </span><span>G1))
</span><span style=color:#616e88># (1368015179489954701390400359078579693043519447331113978918064868415326638035, 9918110051302171585080402603319702774565515993150576347155970296011118125764)
</span><span>
</span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>2</span><span>))
</span><span style=color:#616e88>#(1368015179489954701390400359078579693043519447331113978918064868415326638035, 9918110051302171585080402603319702774565515993150576347155970296011118125764)
</span><span>
</span><span style=color:#616e88># 10G + 11G = 21G
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>eq</span><span>(</span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>10</span><span>)</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>11</span><span>))</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>21</span><span>))
</span></code></pre><p>generate one thousand point in front<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>import </span><span>matplotlib</span><span style=color:#81a1c1>.</span><span>pyplot </span><span style=color:#81a1c1>as </span><span>plt
</span><span style=color:#81a1c1>from </span><span>py_ecc</span><span style=color:#81a1c1>.</span><span>bn128 </span><span style=color:#81a1c1>import </span><span>G1</span><span style=color:#eceff4>, </span><span>multiply</span><span style=color:#eceff4>, </span><span>neg
</span><span style=color:#81a1c1>import </span><span>math
</span><span style=color:#81a1c1>import </span><span>numpy </span><span style=color:#81a1c1>as </span><span>np
</span><span>xs </span><span style=color:#81a1c1>= </span><span>[]
</span><span>ys </span><span style=color:#81a1c1>= </span><span>[]
</span><span style=color:#81a1c1>for </span><span>i </span><span style=color:#81a1c1>in </span><span style=color:#88c0d0;font-style:italic>range</span><span>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span><span style=color:#b48ead>1000</span><span>):
</span><span>    xs</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>append</span><span>(i)
</span><span>    ys</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>append</span><span>(</span><span style=color:#81a1c1>int</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>i)[</span><span style=color:#b48ead>1</span><span>]))
</span><span>    xs</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>append</span><span>(i)
</span><span>    ys</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>append</span><span>(</span><span style=color:#81a1c1>int</span><span>(</span><span style=color:#88c0d0>neg</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>i))[</span><span style=color:#b48ead>1</span><span>]))
</span><span>plt</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>scatter</span><span>(xs</span><span style=color:#eceff4>, </span><span>ys</span><span style=color:#eceff4>, </span><span>marker</span><span style=color:#81a1c1>=</span><span style=color:#a3be8c>'.'</span><span>)
</span><span>plt</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>show</span><span>()
</span></code></pre><p>Addition in a finite field is homomorphic to addition among elliptic curve points (when their order is equal). Because of the discrete logarithm, another party can add elliptic curve points together without knowing which field elements generated those points.<p>The <strong>field modulus</strong> is the modulo we do the curve over. The <strong>curve order</strong> is the number of points on the curve.<p>If you start with a point r and add the curve order o, you will get r back.<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>from </span><span>py_ecc</span><span style=color:#81a1c1>.</span><span>bn128 </span><span style=color:#81a1c1>import </span><span>curve_order</span><span style=color:#eceff4>, </span><span>field_modulus</span><span style=color:#eceff4>, </span><span>G1</span><span style=color:#eceff4>, </span><span>multiply</span><span style=color:#eceff4>, </span><span>eq
</span><span>
</span><span>x </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>5 </span><span style=color:#616e88># chosen randomly
</span><span style=color:#616e88># This passes
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>eq</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>x)</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>x </span><span style=color:#81a1c1>+ </span><span>curve_order))
</span><span>
</span><span style=color:#616e88># This fails
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>eq</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>x)</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>x </span><span style=color:#81a1c1>+ </span><span>field_modulus))
</span></code></pre><p>The implication of this is that (x + y) mod curve_order == xG + yG.<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span>x </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>2 </span><span style=color:#81a1c1>** </span><span style=color:#b48ead>300 </span><span style=color:#81a1c1>+ </span><span style=color:#b48ead>21
</span><span>y </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>3 </span><span style=color:#81a1c1>** </span><span style=color:#b48ead>50 </span><span style=color:#81a1c1>+ </span><span style=color:#b48ead>11
</span><span>
</span><span style=color:#616e88># (x + y) == xG + yG
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>eq</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>(x </span><span style=color:#81a1c1>+ </span><span>y))</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>x)</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>y)))
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>eq</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>(x </span><span style=color:#81a1c1>+ </span><span>y) </span><span style=color:#81a1c1>% </span><span>curve_order)</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>add</span><span>(</span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>x)</span><span style=color:#eceff4>, </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>y)))
</span></code></pre><p>Even though the x + y operation will clearly “overflow” over the curve order, this doesn’t matter. The elliptic curve multiplication is implicitly executing the same operation as taking the modulus before doing the multiplication.<ul><li>Encoding rational numbers: we cannot compute <code>multiply(G1, 1 / 2)</code> but in a finite field, $1 / 2$ can be meaningfully computed as the multiplicative inverse of 2. Transfer <code>1 / 2 </code> to <code>pow(1,2,curve_order)</code> allow us to compute this.</ul><h3 id=details-of-computing-the-modulus-of-a-fraction>*Details of computing the modulus of a fraction</h3><p>For the fraction $\frac{a}{b}$ saitisfied $\gcd(a,b)=1 $ , existing a $c = \frac{a}{b}\ mod\ x$<p>According to Fermat’s little theorem $a^{p-1} = 1(mod \ p)$ we could know<p>$$ a^{p-2}(mod\ p) = (a^{p-1}(mod\ p)*a^{-1}(mod\ p))(mod\ p) \ = a^{-1}(mod\ p) $$<p>It can be further derived that<p>$$ \frac{a}{b} (mod\ p) = (a b^{-1})(mod\ p) \ = (a (mod\ p) * b^{-1} (mod\ p))(mod\ p) \ = (a (mod\ p) * b^{p-2} (mod\ p))(mod\ p) $$<h3 id=every-element-has-an-inverse>Every element has an inverse</h3><p>The <code>py_ecc</code> library supplies us with the neg function which will provide the inverse of a given element. The library encodes the “point at infinity” as a python None.<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>from </span><span>py_ecc</span><span style=color:#81a1c1>.</span><span>bn128 </span><span style=color:#81a1c1>import </span><span>G1</span><span style=color:#eceff4>, </span><span>multiply</span><span style=color:#eceff4>, </span><span>neg</span><span style=color:#eceff4>, </span><span>is_inf</span><span style=color:#eceff4>, </span><span>Z1</span><span style=color:#eceff4>, </span><span>add</span><span style=color:#eceff4>, </span><span>eq
</span><span>
</span><span style=color:#616e88># pick a field element
</span><span>x </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>12345678</span><span style=color:#616e88># generate the point
</span><span>p </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>x)
</span><span>
</span><span style=color:#616e88># invert
</span><span>p_inv </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>neg</span><span>(p)
</span><span>
</span><span style=color:#616e88># every element added to its inverse produces the identity element
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>is_inf</span><span>(</span><span style=color:#88c0d0>add</span><span>(p</span><span style=color:#eceff4>, </span><span>p_inv))
</span><span>
</span><span style=color:#616e88># Z1 is just None, which is the point at infinity
</span><span style=color:#81a1c1>assert </span><span>Z1 </span><span style=color:#81a1c1>is None
</span><span>
</span><span style=color:#616e88># special case: the inverse of the identity is itself
</span><span style=color:#81a1c1>assert </span><span style=color:#88c0d0>eq</span><span>(</span><span style=color:#88c0d0>neg</span><span>(Z1)</span><span style=color:#eceff4>, </span><span>Z1)
</span></code></pre><h3 id=optimized-bn128>optimized_bn128</h3><p>optimized_bn128 is faster while structures EC points as 3-tuples – which are harder to interpret.<h3 id=basic-zero-knowledge-proofs-with-elliptic-curves>Basic zero knowledge proofs with elliptic curves</h3><p>Consider this rather trivial example:<p>Claim: “I know two values x and y such that x + y = 15”<p>Proof: I multiply x by G1 and y by G1 and give those to you as A and B.<p>Verifier: You multiply 15 by G1 and check that A + B == 15G1.<p>Here it is in python<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span style=color:#81a1c1>from </span><span>py_ecc</span><span style=color:#81a1c1>.</span><span>bn128 </span><span style=color:#81a1c1>import </span><span>G1</span><span style=color:#eceff4>, </span><span>multiply</span><span style=color:#eceff4>, </span><span>add
</span><span>
</span><span style=color:#616e88># Prover
</span><span>secret_x </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>5
</span><span>secret_y </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>10
</span><span>
</span><span>x </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>5</span><span>)
</span><span>y </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>10</span><span>)
</span><span>
</span><span>proof </span><span style=color:#81a1c1>= </span><span>(x</span><span style=color:#eceff4>, </span><span>y</span><span style=color:#eceff4>, </span><span style=color:#b48ead>15</span><span>)
</span><span>
</span><span style=color:#616e88># verifier
</span><span style=color:#81a1c1>if </span><span style=color:#88c0d0>multiply</span><span>(G1</span><span style=color:#eceff4>, </span><span>proof[</span><span style=color:#b48ead>2</span><span>]) </span><span style=color:#81a1c1>== </span><span style=color:#88c0d0>add</span><span>(proof[</span><span style=color:#b48ead>0</span><span>]</span><span style=color:#eceff4>, </span><span>proof[</span><span style=color:#b48ead>1</span><span>]):
</span><span>    </span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#a3be8c>"statement is true"</span><span>)
</span><span style=color:#81a1c1>else</span><span>:
</span><span>    </span><span style=color:#88c0d0;font-style:italic>print</span><span>(</span><span style=color:#a3be8c>"statement is false"</span><span>)
</span></code></pre><h3 id=security-assumptions>Security assumptions</h3><p>The security of the elliptic curve encryption algorithm relies on the difficulty of the discrete logarithm problem, which means that it is hard to deduce the value of x from the point <code>(a, b)</code> generated by <code>multiply(G1, x)</code>.<p>There are mores sophisticated algorithms, like the <a href=https://en.wikipedia.org/wiki/Baby-step_giant-step>baby step giant step algorithm</a> that can outperform brute force.<p>It is possible to engineer zero knowledge proofs using basic number theory rather than elliptic curves, but since every modern zero knowledge algorithm uses elliptic curves, they are worth learning.<h3 id=how-ecdsa-malleability-attack-works>How ECDSA malleability attack works.</h3><p>As we documented in our <a href=https://www.rareskills.io/post/smart-contract-security>smart contract security</a> article, given a valid signature (r, s, v, hash(msg)), one can forge another valid signature for the same message by doing the following:<pre style=color:#d8dee9;background-color:#2e3440><code><span>// create a fake s for (r, s, v), then flip v
</span><span>bytes32 s2 = bytes32(uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141) - uint256(s));
</span></code></pre><p>Where does this magic number come from? ECDSA uses the secp256k1 curve, which has the following parameters:<pre style=color:#d8dee9;background-color:#2e3440><code><span>p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
</span><span>y^2 = x^3 + 7 (mod p)
</span><span>order = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
</span></code></pre><p>Note that the order is the same as the magic number.<p>The hack relies on the following identity<pre style=color:#d8dee9;background-color:#2e3440><code><span>multiply(G1, (order - x)) == neg(multiply(G1, x))
</span></code></pre><p>Here is the code to illustrate<pre style=color:#d8dee9;background-color:#2e3440><code><span># Test
</span><span>order = 21888242871839275222246405745257275088548364400416034343698204186575808495617
</span><span>x = 100 # chosen randomly
</span><span>assert multiply(G1, order - x) == neg(multiply(G1, x))
</span></code></pre><p>Recall that neg(multiply(G1, x)) is simply the same x, but with the y value flipped.<pre style=color:#d8dee9;background-color:#2e3440><code><span>x = 100 # chosen randomly
</span><span>assert int(multiply(G1, x)[0]) == int(neg(multiply(G1, x))[0])
</span></code></pre><ul><li>Multiplying the curve order times the generator is the point at infinity.</ul></div></div></section>