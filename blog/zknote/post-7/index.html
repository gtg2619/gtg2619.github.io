<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Arithmetic Circuits | Random thoughts here</title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto flex place-content-between py-16 lg:py-8 font-sans text-6xl lg:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/zknote/> /zknote </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script type=text/x-mathjax-config>
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$']]}
      });
    </script><div class="container mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl lg:text-base">2024-03-10</div><h1 class="w-full mt-4 mb-8 font-serif text-8xl lg:text-4xl text-slate-900 dark:text-slate-300">Arithmetic Circuits</h1><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class=prose-boring><h3 id=arithmetic-circuits>Arithmetic Circuits</h3><p>Zk circuits form a set of constraints that if satisfied, prove a computation was carried out correctly. Zk circuits are sometimes called arithmetic circuits because the “gates” in the circuit are addition and multiplication over a finite field. We are only allowed to use these two operators as a <a href=https://www.rareskills.io/post/rings-and-fields>finite field</a> only has these two operations.<h3 id=prove-a-inverse>prove a inverse</h3><pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span>field_size </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>29 </span><span style=color:#616e88># some prime number
</span><span>
</span><span style=color:#616e88>## Prover
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>compute_inverse</span><span>(a):
</span><span>    </span><span style=color:#81a1c1>return </span><span style=color:#88c0d0;font-style:italic>pow</span><span>(a</span><span style=color:#eceff4>, </span><span style=color:#81a1c1>-</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span>field_size)
</span><span>
</span><span>a </span><span style=color:#81a1c1>= </span><span style=color:#b48ead>22
</span><span>b </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>compute_inverse</span><span>(a)
</span><span>
</span><span style=color:#616e88>## Verifier
</span><span style=color:#81a1c1>assert </span><span>(a </span><span style=color:#81a1c1>* </span><span>b) </span><span style=color:#81a1c1>% </span><span>field_size </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>1
</span></code></pre><h3 id=proving-a-binary-transformation>Proving a binary transformation</h3><p>constrain 1<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span>b1 </span><span style=color:#81a1c1>* </span><span>(</span><span style=color:#b48ead>1 </span><span style=color:#81a1c1>- </span><span>b1) </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>0
</span><span>b2 </span><span style=color:#81a1c1>* </span><span>(</span><span style=color:#b48ead>1 </span><span style=color:#81a1c1>- </span><span>b2) </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>0
</span><span>b3 </span><span style=color:#81a1c1>* </span><span>(</span><span style=color:#b48ead>1 </span><span style=color:#81a1c1>- </span><span>b3) </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>0
</span><span>b4 </span><span style=color:#81a1c1>* </span><span>(</span><span style=color:#b48ead>1 </span><span style=color:#81a1c1>- </span><span>b4) </span><span style=color:#81a1c1>== </span><span style=color:#b48ead>0
</span></code></pre><p>constrain 2<pre class=language-python data-lang=python style=color:#d8dee9;background-color:#2e3440><code class=language-python data-lang=python><span>(</span><span style=color:#b48ead>8 </span><span style=color:#81a1c1>* </span><span>b1) </span><span style=color:#81a1c1>+ </span><span>(</span><span style=color:#b48ead>4 </span><span style=color:#81a1c1>* </span><span>b2) </span><span style=color:#81a1c1>+ </span><span>(</span><span style=color:#b48ead>2 </span><span style=color:#81a1c1>* </span><span>b3) </span><span style=color:#81a1c1>+ </span><span>(</span><span style=color:#b48ead>1 </span><span style=color:#81a1c1>* </span><span>b4) </span><span style=color:#81a1c1>== GIVEN_VALUE
</span></code></pre><h3 id=proving-a-b>Proving a > b</h3><p>Due to something like overflow or underflow in finite field, we could not simply check <code>a - b</code> or <code>b -a</code> to prove it.<p>but it could easily be done in curcuits since we could convert it into a comparison at the bit level.<p>Expand it:<ol><li><p>Proving x is the maximum element in a list of elements: we could use it to check a list was properly sorted.</p><li><p>Proving a list contains no duplicates: we can ask the prover to sort the list (called <strong>auxiliary computations</strong>), verify it is sorted using the methodology from earlier, then check each element of the array to see if the entry next to it is equal.</p></ol><h3 id=hash-functions>hash functions</h3><p>If each step in the hash function can be proven to have been executed correctly, then the entire hash function can be proven to have been executed correctly, <em><strong>without executing the hash function</strong></em>.<p>Proving each step of something like sha256 as a circuit is extremely non-trivial: it requires tens of thousands of constraints to prove every stage of this hash function.</div></div></section>